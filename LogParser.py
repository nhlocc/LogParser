import os
import pandas as pd
import xml.etree.ElementTree as ET
from typing import List, Dict

class LogParser:
    """
    Class to parse log files generated by test automation frameworks and extract failure details.
    """
    def __init__(self):
        """
        Initialize LogParser object.
        """
        self.root = None

    def extract_failure_details(self, element: ET.Element, test_name: str):
        """
        Description:
            Extract failure details from XML element.
        Parameters:
            element (ET.Element): The XML element to extract failure details.
            test_name (str): The name of the test.
        Returns:
            List[Dict[str, str]]: A list of dictionaries containing failure details.
        """
        failure_details = []
        for kw in element.findall('.//kw'):
            kw_status = kw.find('status').attrib['status']
            if kw_status == 'FAIL':
                failure_reason = ""
                for msg in kw.findall('.//msg'):
                    if msg.attrib.get('level') == 'FAIL':
                        failure_reason += msg.text.strip()
                failure_details.append({
                    'source': self.root.find('.//suite').attrib['source'],
                    'test_name': test_name,
                    'keyword_failed': kw.attrib['name'],
                    'failure_reason': failure_reason,
                })
        return failure_details

    def process_data(self, parse_file: str):
        """
        Description:
            Process log file to extract failure details.
        Parameters:
            parse_file (str): Path to the log file.
        Returns:
            List[Dict[str, str]]: A list of dictionaries containing failure details.
        """
        tree = ET.parse(parse_file)
        root = self.root = tree.getroot()
        suite_setup = root.find('.//suite/kw[@type="SETUP"]')
        suite_teardown = root.find('.//suite/kw[@type="TEARDOWN"]')

        processed_data = []
        suite_setup_status = True
        if (suite_setup is not None) and (failure_details := self.extract_failure_details(suite_setup, 'Suite Setup')):
            processed_data.extend(failure_details)
            suite_setup_status = False
        if suite_setup_status:
            for test in root.findall('.//test'):
                test_status = test.find('status').attrib['status']
                if test_status == 'FAIL':
                    test_name = test.attrib['name']
                    failure_details = self.extract_failure_details(test, test_name)
                    processed_data.extend(failure_details)
        if (suite_teardown is not None) and (failure_details := self.extract_failure_details(suite_teardown, 'Suite Teardown')):
                processed_data.extend(failure_details)
        return processed_data

    def write_to_csv(self, data: List[Dict[str, str]], output_file_name: str='output.csv'):
        """
        Description:
            Write extracted failure details to a CSV file.
        Parameters:
            data (List[Dict[str, str]]): List of dictionaries containing failure details.
            output_file_name (str, optional): Name of the output CSV file. Defaults to 'output.csv'.
        Raises:
            Exception: If an error occurs while writing to the CSV file.
        """
        try:
            df = pd.DataFrame(data)
            df.to_csv(output_file_name, index=False)
        except Exception as exc:
            raise Exception(f"Fail to write data to csv file due to error: {exc}")

    def parse_data_results(self, directory: str = './', file_extension: str = '.xml'):
        """
        Description:
            Parse all log files in a given directory and write extracted failure details to a CSV file.
        Parameters:
            directory (str, optional): Directory containing log files. Defaults to './'.
            file_extension (str, optional): File extension of log files. Defaults to '.xml'.
        """
        data = []
        for file_name in os.listdir(directory):
            if file_name.endswith(file_extension):
                parse_file = os.path.join(directory, file_name)
                failed_test_details = self.process_data(parse_file)
                for test_detail in failed_test_details:
                    data.append({
                        'Output file name': file_name,
                        'Test file name': test_detail['source'],
                        'Test case name': test_detail['test_name'],
                        'Keyword failed': test_detail['keyword_failed'],
                        'Failure reason': test_detail['failure_reason'],
                    })
        self.write_to_csv(data)

if __name__=="__main__":
    LogParser().parse_data_results()
